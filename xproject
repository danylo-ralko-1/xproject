#!/usr/bin/env python3
"""xProject CLI - Single entry point for all xproject operations."""

import click
import sys
import os
from pathlib import Path

# Add parent dir to path so core/ is importable
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))


def _load_dotenv():
    """Load .env file from project root if it exists."""
    env_path = Path(__file__).resolve().parent / ".env"
    if not env_path.exists():
        return
    with open(env_path, encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#") or "=" not in line:
                continue
            key, _, value = line.partition("=")
            os.environ.setdefault(key.strip(), value.strip())


_load_dotenv()

from core.config import (
    init_project, load_project, list_projects, save_project,
    get_input_dir, get_answers_dir, get_changes_dir
)
from core.context import check_staleness


@click.group()
@click.version_option(version="3.0.0")
def cli():
    """xProject - AI-powered project scaffolding pipeline.

    Flow: ingest → (conversation: discover, breakdown) → push → enrich

    Additional: validate, breakdown-export, specs-upload, usage
    """
    pass


# --- Project management ---

@cli.command()
@click.argument("project_name")
def init(project_name):
    """Initialize a new project."""
    click.secho(f"\n  Creating project: {project_name}", bold=True)

    org = click.prompt("  ADO Organization", default="")
    project = click.prompt("  ADO Project", default="")
    pat = click.prompt("  ADO PAT Token", hide_input=True, default="")

    proj = init_project(project_name, ado={"organization": org, "project": project, "pat": pat})

    click.secho(f"\n  ✓ Project '{project_name}' created", fg="green", bold=True)
    click.echo(f"    Path: {proj['path']}")
    click.echo(f"\n    Next: drop requirements into {get_input_dir(proj)}")
    click.echo(f"    Then: xproject ingest {project_name}")


@cli.command("list")
def list_cmd():
    """List all projects."""
    projects = list_projects()
    if not projects:
        click.echo("  No projects found.")
        return
    click.secho(f"\n  Projects ({len(projects)}):", bold=True)
    for p in projects:
        proj = load_project(p)
        status = proj.get("status", "unknown") if proj else "error"
        click.echo(f"    {p:30s} [{status}]")


@cli.command()
@click.argument("project_name")
def status(project_name):
    """Show project status and artifact staleness."""
    proj = _load_or_exit(project_name)
    if not proj:
        return

    click.secho(f"\n  Project: {project_name}", bold=True)
    click.echo(f"  Status: {proj.get('status', 'unknown')}")

    state = proj.get("state", {})
    click.secho(f"\n  Pipeline state:", bold=True)

    steps = [
        ("requirements_ingested", "Requirements ingested"),
        ("breakdown_generated", "Breakdown generated"),
        ("ado_pushed", "Pushed to ADO"),
        ("validated", "Design validation run"),
        ("enriched", "AC enriched from designs"),
        ("specs_generated", "Specs generated"),
    ]
    for key, label in steps:
        val = state.get(key, False)
        icon = "✓" if val else "○"
        color = "green" if val else None
        click.secho(f"    {icon} {label}", fg=color)

    # Show changes
    changes = proj.get("changes", [])
    if changes:
        click.secho(f"\n  Change requests: {len(changes)}", bold=True)
        total_delta = sum(c.get("cost_delta", 0) for c in changes)
        click.echo(f"    Total cost impact: ${total_delta:+,.0f}")

    # Staleness warnings
    warnings = check_staleness(proj)
    if warnings:
        click.secho(f"\n  ⚠ Staleness warnings:", fg="yellow")
        for w in warnings:
            click.echo(f"    {w}")


# --- Pipeline commands ---

@cli.command()
@click.argument("project_name")
def ingest(project_name):
    """Parse and ingest raw requirements from input/ folder."""
    proj = _load_or_exit(project_name)
    if not proj:
        return
    _warn_stale(proj, "ingest")

    from commands.ingest import run
    run(proj)
    save_project(proj)


@cli.command("breakdown-export")
@click.argument("project_name")
def breakdown_export(project_name):
    """Export breakdown.json → breakdown.xlsx."""
    proj = _load_or_exit(project_name)
    if not proj:
        return

    from commands.breakdown_export import run
    run(proj)


@cli.command()
@click.argument("project_name")
@click.option("--dry-run", is_flag=True, help="Preview without creating ADO items")
def push(project_name, dry_run):
    """Push stories to Azure DevOps from push_ready.json (or breakdown.json)."""
    proj = _load_or_exit(project_name)
    if not proj:
        return
    _warn_stale(proj, "push")

    from commands.push import run
    run(proj, dry_run=dry_run)
    save_project(proj)


@cli.command()
@click.argument("project_name")
@click.option("--figma-link", required=True, help="Figma file URL")
def validate(project_name, figma_link):
    """Fetch Figma screenshots + ADO stories → validation_bundle.json."""
    proj = _load_or_exit(project_name)
    if not proj:
        return

    from commands.validate import run
    run(proj, figma_link=figma_link)
    save_project(proj)


@cli.command()
@click.argument("project_name")
@click.option("--figma-link", required=True, help="Figma file URL")
@click.option("--story-ids", default=None, help="Comma-separated ADO story IDs to enrich (optional)")
def enrich(project_name, figma_link, story_ids):
    """Fetch Figma screenshots + ADO stories → enrichment_bundle.json."""
    proj = _load_or_exit(project_name)
    if not proj:
        return

    # Parse story IDs if provided
    ids_list = None
    if story_ids:
        ids_list = [s.strip() for s in story_ids.split(",") if s.strip()]

    from commands.enrich import run
    run(proj, figma_link=figma_link, story_ids=ids_list)
    save_project(proj)


@cli.command()
@click.argument("project_name")
def rtm(project_name):
    """Generate Requirements Traceability Matrix wiki page in ADO."""
    proj = _load_or_exit(project_name)
    if not proj:
        return
    _warn_stale(proj, "rtm")

    from commands.rtm import run
    run(proj)


@cli.command("specs-upload")
@click.argument("project_name")
def specs_upload(project_name):
    """Upload YAML spec files to ADO tasks as attachments."""
    proj = _load_or_exit(project_name)
    if not proj:
        return

    from commands.specs_upload import run
    run(proj)


@cli.command()
@click.argument("project_name")
def usage(project_name):
    """Show pipeline operation log (ADO calls, script runs)."""
    proj = _load_or_exit(project_name)
    if not proj:
        return

    from core.usage import get_usage_summary

    summary = get_usage_summary(proj)

    if summary["total_operations"] == 0:
        click.secho(f"\n  No pipeline operation data for '{project_name}' yet.", fg="yellow")
        click.echo("  Operations are logged when running pipeline commands (push, ingest, etc.).")
        return

    click.secho(f"\n  Pipeline Operations for '{project_name}'", bold=True)
    click.echo("")
    click.echo(f"  Total operations:     {summary['total_operations']}")
    click.echo(f"  Total ADO API calls:  {summary['total_ado_api_calls']}")
    click.echo("")

    by_op = summary["by_operation"]
    if by_op:
        click.secho("  Breakdown by operation:", bold=True)
        for op, info in sorted(by_op.items()):
            runs_label = "run" if info["runs"] == 1 else "runs"
            line = f"    {op:20s} {info['runs']:>2} {runs_label}"
            if info["ado_calls"] > 0:
                line += f"   ({info['ado_calls']} API calls)"
            click.echo(line)


@cli.command()
@click.argument("project_name")
@click.option("--log", "do_log", is_flag=True, help="Log a cost entry (interactive)")
@click.option("--scan", is_flag=True, help="Show all Claude Code sessions for this workspace")
def cost(project_name, do_log, scan):
    """Show cumulative AI cost for a project.

    Tracks Claude token costs across sessions. Entries are added by Claude
    during conversation or manually via --log.

    Use --scan to see all Claude Code sessions for this workspace (not
    project-specific — sessions are logged to projects by Claude or manually).
    """
    proj = _load_or_exit(project_name)
    if not proj:
        return

    from core.cost import get_cost_summary, log_session, read_all_sessions_for_cwd

    if scan:
        _scan_sessions(read_all_sessions_for_cwd)
        return

    if do_log:
        _interactive_log(proj, log_session)
        return

    # Show summary
    summary = get_cost_summary(proj)

    if summary["total_sessions"] == 0:
        click.secho(f"\n  No cost data for '{project_name}' yet.", fg="yellow")
        click.echo("  Cost is logged by Claude during conversation, or use:")
        click.echo(f"    xproject cost {project_name} --log    (add entry manually)")
        click.echo(f"    xproject cost {project_name} --scan   (view all workspace sessions)")
        return

    click.secho(f"\n  AI Cost Summary for '{project_name}'", bold=True)
    click.echo("")
    click.secho(f"  Total cost:     ${summary['total_cost_usd']:.2f}", fg="cyan", bold=True)
    click.echo(f"  Total tokens:   {summary['total_tokens']:,}")
    click.echo(f"  Sessions:       {summary['total_sessions']}")
    if summary["first_date"] and summary["last_date"]:
        click.echo(f"  Period:         {summary['first_date']} → {summary['last_date']}")

    click.echo("")
    click.secho("  Session log:", bold=True)
    for e in summary["entries"]:
        date = e.get("date", "?")
        cost_val = e.get("cost_usd", 0)
        desc = e.get("description", "")[:60]
        tokens = e.get("tokens", 0)
        tok_str = f"  ({tokens:,} tokens)" if tokens else ""
        click.echo(f"    {date}  ${cost_val:>7.2f}{tok_str}  {desc}")

    click.echo("")
    click.echo(f"  Tip: Compare against manual effort cost to measure AI ROI.")


def _scan_sessions(read_all_fn):
    """Show all Claude Code sessions for this workspace (informational)."""
    click.echo("\n  Scanning Claude Code transcripts for this workspace...")
    sessions = read_all_fn()

    if not sessions:
        click.secho("  No sessions found.", fg="yellow")
        return

    # Sort by date
    sessions.sort(key=lambda s: s.get("first_activity") or "")

    click.echo(f"  Found {len(sessions)} session(s):\n")
    for s in sessions:
        first = (s.get("first_activity") or "?")[:10]
        last = (s.get("last_activity") or "?")[:10]
        models = ", ".join(s.get("models_used", []))
        date_str = first if first == last else f"{first}→{last}"
        click.echo(
            f"    ${s['total_cost_usd']:>7.2f}  "
            f"{s['total_tokens']:>12,} tokens  "
            f"{date_str}  "
            f"({models})"
        )

    total = sum(s["total_cost_usd"] for s in sessions)
    click.echo(f"\n  Total (all sessions): ${total:.2f}")
    click.echo("\n  Note: These are ALL sessions in this workspace, not project-specific.")
    click.echo("  Claude logs project-specific costs during conversation.")


def _interactive_log(proj, log_fn):
    """Manually log a cost entry."""
    cost_val = click.prompt("  Cost (USD)", type=float)
    desc = click.prompt("  Description", default="Manual entry")
    tokens = click.prompt("  Tokens (0 if unknown)", type=int, default=0)

    log_fn(proj, cost_usd=cost_val, description=desc, tokens=tokens)
    click.secho("  ✓ Entry logged", fg="green")


# --- Helpers ---

def _load_or_exit(project_name: str) -> dict | None:
    """Load project or print error."""
    proj = load_project(project_name)
    if not proj:
        click.secho(f"  ✗ Project '{project_name}' not found.", fg="red")
        click.echo(f"    Run: xproject init {project_name}")
        return None
    return proj


def _warn_stale(proj: dict, command: str) -> None:
    """Print staleness warnings for a command."""
    from core.context import get_dependencies
    deps = get_dependencies(command)
    state = proj.get("state", {})

    for key, msg in deps:
        if not state.get(key, False):
            click.secho(f"  ⚠ {msg}", fg="yellow")


if __name__ == "__main__":
    cli()
